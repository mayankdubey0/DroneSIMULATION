
classdef Drone_Controller < handle
    properties
        drone
        target, error
        derivative, derivative_gain
        A, B, C, D, sys_c 
        Q, R, P, K
        Ad, Bd, time_step, sys_d
        symbols
        position, angles
        motor_speeds
        accel_reading, gyro_reading
        thrusts, X, X_dot, X_pred
        gravity
        roll, pitch, yaw

    end
    
    methods
        function obj = Drone_Controller(drone_object)
            obj.drone = drone_object;
            obj.target = [0;0;0;0;0;0]; % [x; y; z; roll; pitch; yaw]
            obj.error = zeros(6, 1);

            obj.time_step = 0.01;
            obj.roll = 0;
            obj.pitch = 0;
            obj.yaw = 0;
            
            obj.motor_speeds  = [1200; 1200; -800; -800];

            thrust_cons = 0.008;
            air_density = 1.225;
            diameter = 0.1;
            obj.thrusts = thrust_cons * air_density * (diameter^4) * [obj.motor_speeds(1)^2; obj.motor_speeds(2)^2; obj.motor_speeds(3)^2; obj.motor_speeds(4)^2];
            obj.X = zeros(6, 1);
            obj.X_pred = obj.X;
            obj.X_dot = zeros(6, 1);
            obj.gravity = [0; 0; -9.81];

            obj.A = zeros(6, 6);
            obj.A(1:3, 4:6) = eye(3, 3);
            
            obj.B = zeros(6, 4);
            obj.B(4:6, 1:4) = [0, 0, -0.5/obj.drone.Icy, 0.5/obj.drone.Icy;
                               0.5/obj.drone.Icx, -0.5/obj.drone.Icx, 0, 0;
                               0.01, 0.01, -0.01, -0.01];

            obj.C = [1 0 0 0 0 0;
                     0 1 0 0 0 0;
                     0 0 1 0 0 0];
            obj.D = [0 0 0 0;
                     0 0 0 0;
                     0 0 0 0];
            
        end
        
        function update_current_state(obj)
            accel = obj.drone.get_accel();
            gyro = obj.drone.get_gyro();

            obj.roll = obj.roll - obj.time_step * norm(gyro(:, 1));
            obj.pitch = obj.pitch - obj.time_step * norm(gyro(:, 2));
            obj.yaw = obj.yaw - obj.time_step * norm(gyro(:, 3));
            
            ex = [obj.roll, obj.pitch, obj.yaw];
            
            obj.X(1) = asin(-accel(2)/obj.gravity(3));
            obj.X(2) = asin(accel(1)/obj.gravity(3));
            obj.X(3) = ex(3);

            obj.X(1:2) = obj.X(1:2) * 0.2 + ex(1:2)' * 0.8;
            disp(obj.X);
 
        end

        function LQR(obj)
            obj.error = obj.target - obj.X;
            obj.Q = obj.C'*obj.C;
            obj.R = eye(4, 4);
            obj.P = dare(obj.A', obj.B, obj.Q, obj.R);
               
            % Direct computation of P using the Riccati equation
            
            % Calculate K
            obj.K = (obj.R \ obj.B') * obj.P;

            obj.sys_c = ss(obj.A, obj.B, obj.C, obj.D);
            obj.sys_d = c2d(obj.sys_c, obj.time_step);

            obj.Ad = obj.sys_d.A;
            obj.Bd = obj.sys_d.B;
            
            obj.X_pred = obj.Ad * obj.X_pred + obj.Bd * obj.thrusts;

            disp(obj.X_pred);
        end
            
    end

end
