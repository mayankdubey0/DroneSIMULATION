
classdef Drone_Controller < handle
    properties
        drone
        target, error
        derivative, derivative_gain
        A, B, C, D, sys_c 
        Q, R, P, K
        Ad, Bd, time_step, sys_d
        symbols
        position, angles
        motor_speeds
        accel_reading, gyro_reading
        thrusts, X, X_dot
        gravity

    end
    
    methods
        function obj = Drone_Controller(drone_object)
            obj.drone = drone_object;
            obj.target = [0;0;0;0;0;0]; % [x; y; z; roll; pitch; yaw]
            obj.error = zeros(6, 1);
            
            obj.motor_speeds  = [900; 900; -900; -900];

            thrust_cons = 0.008;
            air_density = 1.225;
            diameter = 0.1;
            obj.thrusts = thrust_cons * air_density * (diameter^4) * [obj.motor_speeds(1)^2; obj.motor_speeds(2)^2; obj.motor_speeds(3)^2; obj.motor_speeds(4)^2];
            obj.X = zeros(6, 1);
            obj.X_dot = zeros(6, 1);
            obj.gravity = [0; 0; -9.81];

            obj.A = zeros(6, 6);
            obj.A(1:3, 4:6) = eye(3, 3);
            
            obj.B = zeros(6, 4);
            obj.B(4:6, 1:4) = [0, 0, -0.5/obj.drone.Icy, 0.5/obj.drone.Icy;
                               0.5/obj.drone.Icx, -0.5/obj.drone.Icx, 0, 0;
                               0.01, 0.01, -0.01, -0.01];

            obj.C = [1 0 0 0 0 0;
                     0 1 0 0 0 0;
                     0 0 1 0 0 0;];
            obj.D = [0 0 0 0;
                     0 0 0 0;
                     0 0 0 0];
            
        end
        
        function find_current_state(obj)
            accel = obj.drone.get_accel();
            gyro = obj.drone.get_gyro();


            
            obj.X(1) = asin(-accel(2)/obj.gravity(3));
            obj.X(2) = asin(accel(1)/obj.gravity(3));
            
            disp(gyro(1));
            disp(gyro(2));
            disp(gyro(3));
            disp(obj.X);

        end

        function LQR(obj)
            obj.Q = obj.C'*obj.C;
            obj.R = eye(4, 4);
            obj.P = dare(obj.A', obj.B, obj.Q, obj.R);

            % Direct computation of P using the Riccati equation
            A_transpose = obj.A';
            %obj.P = lyap(A_transpose, -obj.Q - obj.B * (obj.R \ obj.B'));
            
            % Calculate K
            obj.K = (obj.R \ obj.B') * obj.P;
            disp(obj.K);
            
            obj.sys_c = ss(obj.A, obj.B, obj.C, obj.D);
            obj.time_step = 0.1;
            obj.sys_d = c2d(obj.sys_c, obj.time_step);

            obj.Ad = obj.sys_d.A;
            obj.Bd = obj.sys_d.B;
            
            obj.X = obj.A * obj.X + obj.B * obj.thrusts;
        end
            
    end

end
